# C语言学习笔记

## 动态内存相关函数



```c
### 1. void *malloc(size_t size)

### 2. void free(void *ptr)

### 3. void *calloc(size_t nmemb,size_t size);

### 4. void *realloc(void *ptr,size_t size); 
```



   ## 对于malloc:
   \这个函数向系统申请size大小的空间（此处如果size为int则为申请4个，但是int的大小视系统而定），这个地址由指针来掌控，这里也因为指针类型为void,所以指针可转变为任何类型。

此处“掌控”是指：___整个文件只有指针一个人知道那个内存在哪里。___

用法举例之一：

```C
（int *ptr;

​                              ptr = (int *malloc(size of(int))）；
```



（补充概念，malloc函数申请的内存存放在堆上，所以在程序关闭前申请的内存会一直存在）

使用的注意事项：

1. 若循环申请内存而不停下来，则系统会出于自保而停下该程序。 （内存泄漏）    

2. 只有初始设立的指针知道这个内存在哪里额，___若在之后指针指向别处___，则该内存块就没人找得到，会一直占着位置。（内存块丢失）。

​    

## 对于free:
作用是清理由“malloc,calloc和realloc”申请得到的空间，否则该free为“未定义”。值得注意的是，在清理之后指针所指的地址是不变的，而且，若指针的参数为null，则free函数并不做任何操作。

用法举例之一：

```c
free(ptr);
```

## 对于calloc：

它的作用相当于在申请内存的同时对所有内存赋值为  0  。

与malloc函数不太一样的是malloc函数申请后的内存空间里面是随机值。

## 对于realloc : 

它的作用相当于给申请过的内存空间  ___加长____，此时操作的对象为指针。

要注意一下的是：若ptr参数为NULL,则调用该函数相当于malloc(size)

​                            若size参数为，且ptr参数不为NULL，则调用该函数相当于free(ptr)

​                         __（也正是因为上一条，当拉长这个动作变为缩短的时候，内存内的数据可能会丢失）__

​                           最后要注意一下，realloc函数只对malloc,calloc和realloc函数申请的内存起作用。



## 补充概念：（以下指令存放在string.h中）
___memse___：: 使用一个常量字节填充内存空间（memset 函数使用常量字节 c 填充 s 指向的前 n 个字节。）
示例：

```c
void *memset(void *s, int c, size_t n);
```

（通常用于初始化malloc函数申请的内存对象）

___memcpy___：拷贝内存空间。（memcpy 函数从 src 指向的内存空间拷贝 n 个字节到 dest 指向的内存空间。src 和 dest 指向的内存区域不能出现重叠，否则应该使用 memmove 函数。

memcpy 函数并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向___任何___数据类型进行复制。）
示例：

```c
void *memcpy(void *dest, const void *src, size_t n);
```

___memmove___：拷贝内存空间中的内容到另一个内存空间中去。

（memmove 函数从 src 指向的内存空间拷贝 n 个字节到 dest 指向的内存空间。为了避免因为两个内存空间出现重叠而导致的悲剧，该函数会先将 src 指向的内存空间拷贝到一个临时的数组中，完了再从临时数组拷贝到目标内存空间。）
示例：

```c
void *memmove(void *dest, const void *src, size_t n);
```

___memcmp___：比较内存空间。

（memcmp 函数比较 s1 和 s2 指向的两个内存空间前 n 个字节，返回一个小于，等于或大于 0 的数表示 s1 小于、等于或大于 s2。）
示例：memcmp 函数比较 s1 和 s2 指向的两个内存空间前 n 个字节，返回一个小于，等于或大于 0 的数表示 s1 小于、等于或大于 s2。

___memchr___：在内存空间中搜索一个字符。

（memchr 函数扫描 s 指向的内存空间的前 n 个字节，找到第一个匹配字符 c 时停止操作。）
示例：

```c
void *memchr(const void *s, int c, size_t n);
```

  





# C语言内存布局

​                                                               ___（内存大）*高地址*_____

| 命令行参数和环境变量 |
|:---------------------------:|
| 栈                            |
| 未使用的内存空间              |
| 堆                            |
| bss段（存放未初始化的全局变量与静态全局变量，这里的数据在运行前会被初始化为0） |
| 数据段（存放已经初始化的全局变量与局部静态变量，比如指针） |
| 代码段（存放执行代码，也存在字符串常量等只读量，一般为只读） |

​                                                                  ___（内存小）*低地址*：___ 

___堆___：堆的大小视申请的内存段多少而定，是动态的，也可由free等函数来缩短。

___栈___：函数执行的内存区域，一般和堆在一起。

___堆和栈的关系___： 1. 堆的申请和清空由___人___操控，栈由___系统___操控。

   2. 堆上面的东西可以在程序结束前一直停留在那里，且不同函数___可___互相访问。

      栈则是临时使用，当函数返回时，栈被清理，函数间的局部变量___不能___互相访问。

大概总结一下规律: ___越稳定的数据， 越靠前 / 靠底层。___

## 有关于堆和栈的发展方向：

堆和其他一样，是高地址向低地址发展；

栈则是由低地址向高地址发展。

这两种性质带来的结果是：___由代码可求出两个指针变量和它们所指向的内存空间的地址，得到这样一个结论：malloc函数申请的堆上的内存大小虽然不大，但是它们之间的间隔很大，相比于这个，栈是靠在一起的，所以在这个时候，栈，更“环保”一些。___

（在网课中，为了示范栈与堆的高低地址发展，写了这些代码）

```C
#include <stdio.h>
int main()
{
    int a = 0,b = 0;
    int *p = (int *)&b;
    *p = 258;
     printf("%d %d",a,b);
    return 0;
}
```

### 在网课中，a ,b输出的值分别为1,2。

### 按照我的思考，原因是栈是头先进，八个字节char只能存放255个数字，258多出来的三个自然会往a地址进一，剩下的2留在b的地址。

## 但是，

我在codeblocks运行并不是这样，原因有待考察。（输出了0与258.）

 

# 问题，解法及感受

## 问题：因为现在学C语言还没有做一些非常大的项目，都是一些日常的语法和函数的巧用妙用，语法使用上面的错误很容易修正，不值得提出。

###  想法：其实在之前我一直想定义一个动态的数组，因为动态的数组意味着数据不必受限于已知的数据，会给程序带来极大的灵活性，我定义一个静态数组，数组中元素的个数要么已经事先决定好，要么需要用户输入元素的个数，

在___现实___中，

不可能会有永远不变，或者说人类永远可以得到的数据。

这就是malloc 和realloc函数的用处，它们有极大的___延展性___，给了用户和程序员很大很大很大很大很大很大很大很大很大很大很大的操作空间，因为一个庞大的系统离不开最细微的两端逻辑关系。

## 最后，我对C语言的感觉就是：C语言的逻辑相比于其他的语言，可能会更严谨一点，为什么说严谨？之前给我印象比较深刻的是___python___有一句代码是这么写的：

## print （5+6+7）

## 输出的结果是18。

## 我觉得这也稍微反映了“C生万物”这一玩笑说法的来头。C语言的“严谨”，换句话来说也可以说是古板。永远都走直线，而且在所有语言都走直线时，C这个直线在所有语言中是最   刚硬   的一条，我觉得这其实有好有坏，好处应该在于逻辑严密，犹如一张密不透风的巨网，其他语言就如灵巧而分布广阔的陷阱一样。



